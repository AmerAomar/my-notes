# my-notes
## my name is Amer Al-omari, I live in Irbid, I studied software engineering at Al-Hussein Bin Talal University and I want to be a full-stack developer. 

#
## I learned thats :
the breaking functionality, fixing bug and it leads to aother bug, how hard to add new feature, to leave of a code and start writing a new one, these are a common issuse in programming <br>
<br>
To avoid these issuse, the developers should develop a mindset that every developer should have.<br>
Here are the key points:
<br>


 1. Understand the purpos of the software: it's to help people, not to show off how genius you are

<br>

 2. all programmers are designers: if you desing a bad system your software life time will be short

<br>

3. misunderstanding: developers who don't fully understand their work tend to develop complex systems, you must be sure that you fully understand the systems and tools you are working with.

<br>

4. Simplicity: a “bad developer” is just somebody who fails to reduce complexity, a good developer creates things that are easy to understand so that it’s really easy to shake out all the bugs.

<br>

5. Complexity: The source of many software failures is complexity, You start out with a simple project that can be completed in one month. Then you add complexity, and the task will take up to three months, First, you will exactly know your software purpose and its definition. Second, you will be as simple as possible in every piece of code you write. Third, when a new feature or change request comes to the discussion table, you will evaluate them based on your software purpose and question them.

<br>

6. Maintenance: Maintenance is one of the most important things in software development. Unfortunately, developers usually ignore how important it is, There will always be some implementation of changes. Not only you have to implement them, but you also have to maintain them over time

<br>

7. Consistency: Code that isn’t consistent becomes harder to understand. Don’t keep forcing developers to relearn the way your system works every time they look at a new piece of it.

<br>

8. Prioritizing: When you face many possible directions, how do you decide which option is the best? What to focus on and which features you should implement?<br>
To answer those questions, there are three important factors that will help you make a better decision.

<br>

+ The desirability of a change: How much do you want that change to happen?

+ The value of a change: How much value does the change offer? How much does it help your users?

+ The effort required to perform the change: How much work will you need to do to accomplish this change?

<br>

9. Solving Problems: The first step is understanding. Know exactly what is being asked. Most hard problems are hard because you don’t understand them. Write down your problem and try to explain it to someone else.
The second step is planning. Don’t take action. Sleep on it. Give your brain some time to analyze the problem and process the information but don’t spend too much time on planning

The third step is dividing. Don’t try to solve one big problem. When you look at the problem as a whole, it can scare you. Divide it into smaller tasks and solve each sub-problem one by one. Once you solve each sub-problem, you connect the dots.



10. Good enough is fine: Whether creating a new project or adding a feature to existing system developers tend to plan everything out in detail from the beginning,

they want the first version to be perfect. They don’t focus on the problem they will solve and how their software will help people. <br>


Start small, improve it, then extend.

The incremental design should be your guide. Here is how you would use it to design a calculator:


+ Plan a system that does only addition and nothing else.


+ Implement it.

+ Improve the now-existing system’s design so you can add other operations also.


+ Plan subtraction and repeat step 2 and 3.


+ Plan multiplication and repeat step 2 and 3.


+ Plan division and repeat step 2 and 3.
 

11. Predictions: “A prediction is simply a forecast that something will happen in the future. It could be factual and based on some kind of objective data or it could be based on an assumption.” ***Being too generic involves a lot of code that isn’t needed***<br>
You can’t predict the future, so no matter how generic your solution is, it will not be generic enough to satisfy the actual future requirements you will have. Most probably, this time will never come and the code you wrote to solve future problems will increase complexity, so don’t predict to future. Be only as generic as you know you need to be right now.

<br>

12. Assumptions: one of the great killers of a software project is assumptions, an assumption can kill a software project, to avoid assumptions follow this simple rule:<br>
Code should be designed based on what you know now, not on what you think will happen in the future.

<br>

13. Automation:
don’t spend your time on repetitive tasks. Set them up and forget about them. They can work while you are sleeping. When you realize that you are doing something again and again, just remember this rule:

    If you can automate it, automate it.

<br>
14. Productivity: your main goal should be keeping your code base as small as possible. The question is not How can I write more code? rather it should be “How can I remove more code?”


15. Testing


<br>

16. (Under)Estimation

<br>

17. Running Away From Rewriting: there are many cases that you should consider to rewrite your code from scratch But here is simple advice for you:

***Refactoring should be the first option.***
<br>

18. Documentation and Commenting
<br>

19. Picking Technologies (Tools, Libraries, etc.)

<br>

20. Self-Development
<br>

21. Don’t be a hero: ***Don’t be obsessive. Know when to quit. Don’t hesitate to ask for help.***

</li>
<br>

22. Don’t Ask Questions… Ask For Help.

